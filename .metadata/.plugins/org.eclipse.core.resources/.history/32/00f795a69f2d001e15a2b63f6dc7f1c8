/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

// RCC   0x40023800
// Offset RCC = 0x30
// Mask = 0x00000010

// GPIOA = 0x40020000
// MODER = 0x00
// ODR   = 0x14

#include <stdint.h>

// Direcciones de los registros de control del GPIOA y RCC
#define RCC_BASE_ADDR       0x40023800
#define GPIOA_BASE_ADDR     0x40020000

#define RCC_AHB1ENR_OFFSET  0x30
#define GPIOA_MODER_OFFSET  0x00
#define GPIOA_ODR_OFFSET    0x14

// Punteros a los registros de control del GPIOA y RCC
volatile uint32_t *p_RCC_AHB1ENR = (uint32_t *)(RCC_BASE_ADDR + RCC_AHB1ENR_OFFSET);
volatile uint32_t *p_GPIOA_MODER = (uint32_t *)(GPIOA_BASE_ADDR + GPIOA_MODER_OFFSET);
volatile uint32_t *p_GPIOA_ODR   = (uint32_t *)(GPIOA_BASE_ADDR + GPIOA_ODR_OFFSET);

int main() {
    // Habilitar el reloj para el puerto GPIOA
    *p_RCC_AHB1ENR |= (1 << 0);

    // Configurar el pin del LED2 (PA5) como salida
    *p_GPIOA_MODER &= ~(0x3 << 10); // Limpiar los bits correspondientes a PA5
    *p_GPIOA_MODER |= (0x1 << 10);  // Establecer el bit 10 a 1 (salida)

    // Encender el LED2 (PA5)
    *p_GPIOA_ODR |= (1 << 5); // Establecer el bit 5 para encender el LED

    while (1) {
        // Permanecer en un bucle infinito para mantener el LED encendido
    }

    return 0;
}


